import { db } from '$lib/server/db';
import { invoice, client, task, invoiceItems } from '$lib/server/db/schema';
import { eq, desc } from 'drizzle-orm';
import type { Actions, PageServerLoad } from './$types';
import { fail, redirect } from '@sveltejs/kit';

export const load: PageServerLoad = async () => {
    const clients = await db.query.client.findMany({
        orderBy: [desc(client.created_at)]
    });
    const tasks = await db.query.task.findMany({
        where: eq(task.isDone, true), // Only finished tasks? Or all? User said "items can be taken from a task"
        with: {
            client: true
        }
    });

    // Fetch company settings for the UI
    const company = await db.query.companySettings.findFirst();

    // Fetch products for the item description combobox
    const products = await db.query.product.findMany();

    return { clients, tasks, company, products };
};

export const actions: Actions = {
    default: async ({ request }) => {
        const formData = await request.formData();

        // --- 1. Client Handling ---
        let clientId = formData.get('clientId') ? Number(formData.get('clientId')) : null;
        const isNewClient = formData.get('isNewClient') === 'true';

        if (isNewClient) {
            const newClientName = formData.get('newClientName') as string;
            // Basic validation for new client
            if (!newClientName) return fail(400, { message: 'Client Name is required' });

            const [createdClient] = await db.insert(client).values({
                name: newClientName,
                address: formData.get('newClientAddress') as string,
                registrationNumber: formData.get('newClientRegNo') as string,
                vatNumber: formData.get('newClientVatNo') as string,
                email: formData.get('newClientEmail') as string,
                // Add defaults for required fields if needed
            }).returning({ id: client.id });

            clientId = createdClient.id;
        }

        if (!clientId) {
            return fail(400, { message: 'Client is required' });
        }


        // --- 2. Invoice Details ---
        const taskId = formData.get('taskId') ? Number(formData.get('taskId')) : null;
        const issueDate = formData.get('issueDate') as string;
        const dueDate = formData.get('dueDate') as string;
        const notes = formData.get('notes') as string;
        const language = (formData.get('language') as string) || 'lv';

        // --- 3. Items Handling ---
        // Expecting items to be passed as a JSON string 'items'
        const itemsRaw = formData.get('items');
        let items: any[] = [];
        try {
            items = itemsRaw ? JSON.parse(itemsRaw as string) : [];
        } catch (e) {
            return fail(400, { message: 'Invalid items data' });
        }

        if (items.length === 0) {
            return fail(400, { message: 'At least one item is required' });
        }

        // --- 4. Calculations ---
        // Recalculate server-side to be safe
        let subtotal = 0;
        const processedItems = items.map((item: any) => {
            const qty = Number(item.quantity) || 1;
            const price = Number(item.price) || 0; // In cents
            const total = qty * price;
            subtotal += total;
            return {
                description: item.description,
                unit: item.unit,
                quantity: qty,
                price: price,
                total: total
            };
        });

        const rawTaxRate = parseFloat(formData.get('vatRate') as string);
        const taxRate = isNaN(rawTaxRate) ? 21.0 : rawTaxRate;
        const taxAmount = Math.round(subtotal * (taxRate / 100));
        const total = subtotal + taxAmount;


        // --- 5. Invoice Number Generation ---
        // Simple generation: Date + Count. Ideally this should be more robust (transactional)
        const dateStr = new Date().toLocaleDateString('lv-LV', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\./g, '');
        // format ddmmyyyy - check clashes
        // For now, let's keep the existing logic or simple increment
        // User said: "Invoice number should be autogenerated. Date aswell."

        const count = await db.$count(invoice);
        const invoiceNumber = `${dateStr}-${count + 1}`;


        // --- 6. Database Insert ---
        try {
            const [newInvoice] = await db.insert(invoice).values({
                invoiceNumber,
                taskId,
                clientId,
                issueDate,
                dueDate,
                subtotal, // Now derived from items
                taxRate,
                taxAmount,
                total,
                notes,
                language,
                status: 'draft'
            }).returning({ id: invoice.id });

            // Insert Items
            if (processedItems.length > 0) {
                await db.insert(invoiceItems).values(
                    processedItems.map((item: any) => ({
                        invoiceId: newInvoice.id,
                        ...item
                    }))
                );
            }

        } catch (error) {
            console.error(error);
            return fail(500, { message: 'Failed to create invoice' });
        }

        throw redirect(303, '/rekini');
    }
};
